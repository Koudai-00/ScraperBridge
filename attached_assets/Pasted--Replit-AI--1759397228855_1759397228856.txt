# Replit AIへの指示プロンプト

あなたはエキスパートのバックエンドエンジニアです。
これから、動画からレシピを抽出するモバイルアプリのバックエンドシステムを構築します。
このシステムの主な目的は、モバイルアプリから動画URLを受け取り、その動画をAIで解析してレシピをテキスト化し、結果をアプリに返すことです。

以下のすべての要件を、PythonとFastAPIフレームワーク、データベースはPostgreSQLを使用して実装してください。

---

### **要件1：データベーステーブルの構築**

AIの処理結果をキャッシュするため、またAI利用料を追跡するために、以下の2つのテーブルをPostgreSQLに作成してください。

**1. `extracted_recipes`テーブル** (処理結果のキャッシュ用)
| カラム名         | データ型    | 説明                                                           |
| ---------------- | ----------- | -------------------------------------------------------------- |
| `recipe_id`      | UUID        | レシピの一意なID。プライマリーキー。                           |
| `video_url`      | TEXT        | 解析した動画のURL。重複リクエストを避けるためUNIQUE制約を付与。 |
| `extracted_text` | TEXT        | AIによって抽出されたレシピのテキスト。                         |
| `created_at`     | TIMESTAMPTZ | このレコードが作成された日時。                                 |
| `log_id`         | UUID        | `recipe_extraction_logs`テーブルへの参照（外部キー）。           |

**2. `recipe_extraction_logs`テーブル** (AIコスト追跡用)
| カラム名            | データ型        | 説明                                             |
| ------------------- | --------------- | ------------------------------------------------ |
| `log_id`            | UUID            | ログの一意なID。プライマリーキー。                 |
| `user_id`           | TEXT            | この処理を実行したユーザーのID。                   |
| `video_url`         | TEXT            | 処理した動画のURL。                              |
| `created_at`        | TIMESTAMPTZ     | 処理が実行された日時。                             |
| `ai_model`          | VARCHAR(50)     | 使用したAIモデル名 (例: 'gemini-1.5-pro')。      |
| `calculated_cost_usd` | DECIMAL(10, 8)  | バックエンドで計算した米ドルでのコスト。         |
| `status`            | VARCHAR(20)     | 処理のステータス (例: 'SUCCESS', 'CACHE_HIT', 'ERROR')。 |

---

### **要件2：メイン機能である「レシピ抽出API」の構築**

モバイルアプリから呼び出される、システムの中心的なAPIを構築してください。

**APIエンドポイント:**
- **`POST /api/v1/extract-recipe`**

**セキュリティ:**
- このAPIは、モバイルアプリからのリクエストのみを受け付けるように、APIキーで保護してください。
- リクエストヘッダー `X-API-Key` に正しいAPIキーが含まれているか検証し、キーはReplit Secretsの `APP_API_KEY` から読み込んでください。

**機能ロジック:**
1.  リクエストボディから `{"video_url": "..."}` を受け取ります。
2.  まず、`extracted_recipes`テーブルを検索し、同じ`video_url`のデータが既に存在するか（キャッシュがあるか）を確認します。
3.  **もしキャッシュが存在する場合:** AIを呼び出さず、データベースから`extracted_text`を直接取得し、アプリに返します。この際、`recipe_extraction_logs`には`status`を'CACHE_HIT'として簡単なログを記録してください（コストは0）。
4.  **もしキャッシュが存在しない場合:**
    a. **GoogleのVertex AI Geminiモデル**を使用して、動画からレシピを抽出する処理を実装してください。（この部分は、実際の動画ダウンロードやフレーム抽出の複雑なロジックの代わりに、`google-cloud-aiplatform`ライブラリを呼び出す placeholder/stub 関数として実装してください）
    b. AIの処理が完了したら、その結果（レシピテキスト）と使用量（トークン数など）を受け取ります。
    c. 受け取った使用量からAI利用料（米ドル）を計算します。
    d. `recipe_extraction_logs`テーブルに、コスト、ステータス('SUCCESS')などの詳細なログを記録します。
    e. `extracted_recipes`テーブルに、新しいレシピテキストをキャッシュとして保存します。
    f. 最後に、AIから受け取ったレシピテキストをアプリに返します。
5.  Google Cloudの認証情報は、Replit Secretsの `GOOGLE_APPLICATION_CREDENTIALS_JSON` から読み込むように実装してください。

---

### **要件3：Appsmith連携用の「ダッシュボードAPI」の構築**

Appsmithの管理画面からAI利用コストのデータを取得するための、内部専用APIを構築してください。

**APIエンドポイント:**
- **`GET /api/internal/metrics`**

**セキュリティ:**
- `X-API-Key`ヘッダーによるAPIキー認証を必須とします。キーはReplit Secretsの `INTERNAL_API_KEY` （`APP_API_KEY`とは別のキー）から読み込んでください。

**機能:**
- `recipe_extraction_logs`テーブルから過去30日間のデータを日付ごとに集計し、各日の合計コスト(`total_cost`)を計算して、以下のJSON形式で返してください。

**レスポンスJSONのフォーマット例:**
```json
[
  { "date": "2025-10-01", "total_cost": 15.72 },
  { "date": "2025-10-02", "total_cost": 18.05 }
]